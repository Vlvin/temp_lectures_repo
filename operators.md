# Словарь файла:
r -> регистр (register) на процессоре в который можно положить/взять значение  
m -> буфер или некоторая ячейка в памяти (memory). можно взять/изменить ее значение но она не находится на процессоре  
i -> мгновенная память (immediate memory), нигде не хранится, изменить невозможно  
op<номер> -> операнд под номером <номером> (например ``` add m/r i |-> op1 += op2 ```)  
byte -> 1 байт  
word -> 2 байт  
dword -> 4 байт  
qword -> 8 байт  
: |-> операция конкатенации регистров в один большой регистр (например ah:al эквивалентен ax)  

# Операторы
## Понятные арифметические операторы
``` add m/r i/m/r |-> op1 += op2 (addition) ```  
``` sub m/r i/m/r |-> op1 -= op2 (substraction) ```  
``` inc m/r |-> op1 += 1 или op1++ (increment) ```  
``` dec m/r |-> op1 -= 1 или op1-- (decrement) ```  
``` neg m/r |-> op1 = -op1 (negation) ```  
## Странные арифметические операторы
Для использования следующих операторов понядобится следующая таблица (1)
```
byte |-> ah:al
word |-> dx:ax
dword |-> edx:eax
```
### Беззнаковое умножение
#### Синтаксис:
``` mul m/r ```
#### Действия:
Для начала берется размер операнда op1 (обозначим за size(op1)).  
Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
Затем в r1:r2 записывается op1*r2 где op1 и r2 считаются неотрицательными числами  
### Беззнаковое деление
#### Синтаксис:
``` div m/r ```
#### Действия:
Для начала берется размер операнда op1 (обозначим за size(op1)).  
Далее через size(op1) находится пара регистров r1:r2 в таблице (1).  
Затем в r1 записывается r2%op1, А в r2 записывается r2/op1 где op1 и r2 считаются неотрицательными числами  
### Знаковое yмножение
Существует 3 варианта знакового умножения

1)
    #### Синтаксис:
    ``` imul m/r ```
    #### Действия:
    Для начала берется размер операнда op1 (обозначим за size(op1)).  
    Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
    Затем в r1:r2 записывается op1*r2  

2) ``` imul m/r i/m/r |-> op1 *= op2 ```
3) ``` imul m/r i/m/r i/m/r |-> op1 = op2*op3 ```
### Знаковое деление
Существует 3 варианта знакового деления

1)
    #### Синтаксис:
    ``` idiv m/r ```
    #### Действия:
    Для начала берется размер операнда op1 (обозначим за size(op1)).  
    Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
    Затем в r1 записывается r2%op1, А в r2 записывается r2/op1 где op1 и r2  

2) ``` idiv m/r i/m/r |-> op1 /= op2 ```
3) ``` idiv m/r i/m/r i/m/r |-> op1 = op2/op3 ```
## Операторы конвертации
``` cbw |-> переносит значение из al в ax расширяя с учетом знака (conver byte to word) ```  
``` cwd |-> переносит значение из ax в dx:ax расширяя с учетом знака (conver word to dword) ```  
``` cdq |-> переносит значение из eax в edx:eax расширяя с учетом знака (conver dword to qword) ```  
``` cwde |-> переносит значение из ax в eax расширяя с учетом знака (conver word to dword extended) ```  
## Логические операторы
``` not m/r |-> побитовое отрицание. "переключает" каждый бит op1 (not 0011 |-> 1100) ```  
``` and m/r i/m/r |-> побитовое и. op1 &= op2 (and 0011 0101 |-> 0001) ```  
``` or m/r i/m/r |-> побитовое или. op1 |= op2 (or 0011 0101 |-> 0111) ```  
``` xor m/r i/m/r |-> побитовое исключающее или. op1 ^= op2 (xor 0011 0101 |-> 0110) ```  
### Сдвиги
``` 
shl m/r i/r |-> битовый сдвиг влево.
op1 <<= op2 
Примеры:
    shl 00111 1 |-> 01110
    shl 00110 1 |-> 01100
```
```
shr m/r i/r |-> битовый сдвиг вправо. 
op1 >>= op2 
Примeры:
    shr 01100 1 |-> 00110
    shr 11100 1 |-> 01110
```
```
sal m/r i/r |-> арифметический сдвиг влево. 
op1 *= 2^op2 (2 в степень op2) 
Примеры 
    sal 01111 1 |-> 11110 
    sal 01110 1 |-> 11100 
```
```
sar m/r i/r |-> арифметический сдвиг вправо. 
op1 /= 2^op2 (2 в степень op2) 
Примеры:
     sar 11100 1 |-> 11110 
     sar 01100 1 |-> 00110 
```
#### Замечание
В качестве второго оператора для сдвига подходит либо мгновенная память либо регистр cl. по неизвестным причинамдругие регистры не подходят

# Флаги
Ранее мы рассматривали регистр eflags размером 16 бит или word  
В регистр flags автоматически записывается состояние программы.  
Записывается оно побитово)) т.е. конкретный бит и отвечает за конкретное состояние  
Разметка flags следующая:  
``` \[ 15 | 14 | 13 | 12 | 11 OF | 10 DF | 9 IF | 8 TF | 7 SF | 6 ZF | 5 | 4 AF | 3 | 2 PF | 1 | 0 CF \] ```
Сегодня рассмотрим флаги OF, SF, ZF, CF
## CF (Carry Flag)
При различных операциях результат может не поместиться в регистр или буфер, тогда первый непоместившийся в буфер бит записывается в CF  
Например 
1) ```1010 + 1010 = 10100``` но т.к. в данном случае места всего 4 бита, то результат будет ```0100``` а CF будет записана 1
2) ```1010 << 2 = 101000``` но т.к в данном случае места всего 4 бита, то результатом будет ```1000``` а в CF будет записан 0
2) ```0100 - 1000 = 1110``` но т.к в данном случае операция беззнаковая, то результатом будет ```1000``` а в CF будет записана 1
## OF (Overflow Flag)
OF проверяет логику арифметических операций. Если логика была нарушена изза переполнения регистра/буфера
Конкретная логика такая:
1) при умножении 2х чисел одного знака должно получиться положительное число
2) при умножении положительного числа на отрицательное должно получиться отрицательное
3) при сложении 2х чисел знака P должно получиться число такого же знака P
Если логика в последней операции нарушена то OF принимает значение 1, иначе 0
## ZF (Zero Flag)
ZF проверяет значение последней арифметической операции
ZF = 0 если значение не равно 0, иначе ZF = 1
## SF (Sign Flag)
SF проверяет значение последней арифметической операции
SF = 0 если значение >= 0, иначе SF = 1
