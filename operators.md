# Словарь файла:
r -> регистр (register) на процессоре в который можно положить/взять значение  
m -> буфер или некоторая ячейка в памяти (memory). можно взять/изменить ее значение но она не находится на процессоре  
i -> мгновенная память (immediate memory), нигде не хранится, изменить невозможно  
op<номер> -> операнд под номером <номером> (например ``` add m/r i |-> op1 += op2 ```)  
byte -> 1 байт  
word -> 2 байт  
dword -> 4 байт  
qword -> 8 байт  
: |-> операция конкатенации регистров в один большой регистр (например ah:al эквивалентен ax)  
0x12 -> Число в системе счисления с основанием 16 (0x12 == 18)
0b11 -> Число в системе счисления с основанием 2 (0b11 == 3)
oplabel -> название метки в коде

# Операторы
## Присваивание значений (a = 5)
Для присвоения памяти или некоторому регистру значения существует семейство операторов mov
### Обыкновенное присваивание
```mov m/r m/r/i |-> op1 = op2```
op1 и op2 должны быть одного размера если op2 не immediate memory
### Присваивание с расширением размера
В случае с `mov` операторы должны быть одного размера, но если мы хотим расширить размер то для этого есть 2 операции  
#### Беззнаковое присваивание
```movzx m/r m/r |-> op1 = op2```  
интерпретирует значение в op2 как беззнаковое и заполняет 0 все остальные биты
Например:  
1) ```1010 == 00001010```
2) ```0101 == 00000101```
#### Знаковое присваивание
```movsx m/r m/r |-> op1 = op2```
интерпретирует значение в op2 как знаковое и заполняет старшим битом op2 все остальные биты
Например:  
1) ```1010 == 11111010```
2) ```0101 == 00000101```
#### Замечание
op1 должен быть больше чем op2 например если размер op2 - 2 байта, то размер op1 может быть только 4 байта

## Понятные арифметические операторы
``` add m/r i/m/r |-> op1 += op2 (addition) ```  
``` sub m/r i/m/r |-> op1 -= op2 (substraction) ```  
``` inc m/r |-> op1 += 1 или op1++ (increment) ```  
``` dec m/r |-> op1 -= 1 или op1-- (decrement) ```  
``` neg m/r |-> op1 = -op1 (negation) ```  
### Полное умножение
При сложении 2х чисел которые не помещаются в 32 битные регистры, нам придется делать сложение поэтапным  
Для этого нам нужно записать каждое число в 2 регистра, сложить нижние половины и сложить верхние с переносом десятка из сложения нижних половин  
Например (использую 2 байтовые числа для простоты)
```0x5FFF + 0x5FFF = [0x5F + 0x5F + CF]:[0xFF + 0xFF] = [0xBF]:[0xFE]```
Где CF получается в процессе сложения нижних половин числа (Смотри Флаги:CF)  
Для сложения с использованием CF существует следующий оператор
```adc m/r, m/r/i |-> op1 += op2 + CF```
### Полное вычитание
При вычитании 2х чисел которые не помещаются в 32 битные регистры, нам придется делать вычитание поэтапным  
Для этого нам нужно записать каждое число в 2 регистра, вычесть нижние половины друг из друга и вычесть верхние с заимствованием десятка для вычитания нижних половин  
Например (использую 2 байтовые числа для простоты)
```0x5EEE - 0x3FFF = [0x5E - 0x4F - CF]:[0xEE - 0xFF] = [0x1E]:[0xEF]```
Где CF получается в процессе вычитания нижних половин числа (Смотри Флаги:CF)  
Для сложения с использованием CF существует следующий оператор
```sbb m/r, m/r/i |-> op1 -= op2 - CF```
## Странные арифметические операторы
Для использования следующих операторов понядобится следующая таблица (1)
```
byte |-> ah:al
word |-> dx:ax
dword |-> edx:eax
```
### Беззнаковое умножение
#### Синтаксис:
``` mul m/r ```
#### Действия:
Для начала берется размер операнда op1 (обозначим за size(op1)).  
Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
Затем в r1:r2 записывается op1*r2 где op1 и r2 считаются неотрицательными числами  
### Беззнаковое деление
#### Синтаксис:
``` div m/r ```
#### Действия:
Для начала берется размер операнда op1 (обозначим за size(op1)).  
Далее через size(op1) находится пара регистров r1:r2 в таблице (1).  
Затем в r1 записывается (r1:r2)%op1, А в r2 записывается (r1:r2)/op1 где op1 и r1:r2 считаются неотрицательными числами  
#### Замечание:
### Знаковое yмножение
Существует 3 варианта знакового умножения

1)
    #### Синтаксис:
    ``` imul m/r ```
    #### Действия:
    Для начала берется размер операнда op1 (обозначим за size(op1)).  
    Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
    Затем в r1:r2 записывается op1*r2  

2) ``` imul m/r i/m/r |-> op1 *= op2 ```
3) ``` imul m/r i/m/r i/m/r |-> op1 = op2*op3 ```
### Знаковое деление
1)
    #### Синтаксис:
    ``` idiv m/r ```
    #### Действия:
    Для начала берется размер операнда op1 (обозначим за size(op1)).  
    Далее через size(op1) находится пара регистров r1:r2 в таблице (1)  
    Затем в r1 записывается (r1:r2)%op1, А в r2 записывается (r1:r2)/op1  

## Операторы конвертации
``` cbw |-> переносит значение из al в ax расширяя с учетом знака (conver byte to word) ```  
``` cwd |-> переносит значение из ax в dx:ax расширяя с учетом знака (conver word to dword) ```  
``` cdq |-> переносит значение из eax в edx:eax расширяя с учетом знака (conver dword to qword) ```  
``` cwde |-> переносит значение из ax в eax расширяя с учетом знака (conver word to dword extended) ```  
## Логические операторы
``` not m/r |-> побитовое отрицание. "переключает" каждый бит op1 (not 0011 |-> 1100) ```  
``` and m/r i/m/r |-> побитовое и. op1 &= op2 (and 0011 0101 |-> 0001) ```  
``` or m/r i/m/r |-> побитовое или. op1 |= op2 (or 0011 0101 |-> 0111) ```  
``` xor m/r i/m/r |-> побитовое исключающее или. op1 ^= op2 (xor 0011 0101 |-> 0110) ```  
### Сдвиги
``` 
shl m/r i/r |-> битовый сдвиг влево.
op1 <<= op2 
Примеры:
    shl 00111 1 |-> 01110
    shl 00110 1 |-> 01100
```
```
shr m/r i/r |-> битовый сдвиг вправо. 
op1 >>= op2 
Примeры:
    shr 01100 1 |-> 00110
    shr 11100 1 |-> 01110
```
```
sal m/r i/r |-> арифметический сдвиг влево. 
op1 *= 2^op2 (2 в степень op2) 
Примеры 
    sal 01111 1 |-> 11110 
    sal 01110 1 |-> 11100 
```
```
sar m/r i/r |-> арифметический сдвиг вправо. 
op1 /= 2^op2 (2 в степень op2) 
Примеры:
     sar 11100 1 |-> 11110 
     sar 01100 1 |-> 00110 
```
#### Замечание
В качестве второго оператора для сдвига подходит либо мгновенная память либо регистр cl. по неизвестным причинамдругие регистры не подходят

# Флаги
Ранее мы рассматривали регистр eflags размером 16 бит или word  
В регистр flags автоматически записывается состояние программы.  
Записывается оно побитово)) т.е. конкретный бит и отвечает за конкретное состояние  
Разметка flags следующая:  
``` \[ 15 | 14 | 13 | 12 | 11 OF | 10 DF | 9 IF | 8 TF | 7 SF | 6 ZF | 5 | 4 AF | 3 | 2 PF | 1 | 0 CF \] ```
Сегодня рассмотрим флаги OF, SF, ZF, CF
## CF (Carry Flag)
При различных операциях результат может не поместиться в регистр или буфер, тогда первый непоместившийся в буфер бит записывается в CF  
Например 
1) ```1010 + 1010 = 10100``` но т.к. в данном случае места всего 4 бита, то результат будет ```0100``` а CF будет записана 1
2) ```1010 << 2 = 101000``` но т.к в данном случае места всего 4 бита, то результатом будет ```1000``` а в CF будет записан 0
2) ```0100 - 1000 = 1110``` но т.к в данном случае операция беззнаковая, то результатом будет ```1000``` а в CF будет записана 1
## OF (Overflow Flag)
OF проверяет логику арифметических операций. Если логика была нарушена изза переполнения регистра/буфера
Конкретная логика такая:
1) при умножении 2х чисел одного знака должно получиться положительное число
2) при умножении положительного числа на отрицательное должно получиться отрицательное
3) при сложении 2х чисел знака P должно получиться число такого же знака P
Если логика в последней операции нарушена то OF принимает значение 1, иначе 0
## ZF (Zero Flag)
ZF проверяет значение последней арифметической операции
ZF = 0 если значение не равно 0, иначе ZF = 1
## SF (Sign Flag)
SF проверяет значение последней арифметической операции
SF = 0 если значение >= 0, иначе SF = 1

# Ветвление потока (if/else, loops, etc.)
## Сравнение
```cmp m/r m/r/i```
Сравнение op1 с op2 которое отразится на флагах (например при op1 < op2, CF = 1, ZF = 0)
```test m/r m/r/i```
Логическое сравнение (and) op1 и op2

## Прыжки
Для использования прыжков нам необходим концепт меток (labels)  
Метка - это точка в программе которую мы отметили именем  
Например в каждой программе есть метка ```main:```
Такую метку можно использовать для прыжка на нее
### Безусловный прыжок
```jmp oplabel```
совершит прыжок на метку oplabel
### Условные прыжки (j*)
Условные прыжки проверяют состояние программы отраженное операциями ```cmp``` и ```test```
#### Прыжки после сравнения знаковых
```jl oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был меньше (less) чем op2
```jle oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был меньше либо равен (less or equals) чем op2
```jg oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был больше (greater) чем op2
```jge oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был больше либо равен (greater or equals) чем op2
```je oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 равен (equals) op2

#### Прыжки после сравнения беззнаковых
```jb oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был меньше (below) чем op2
```jbe oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был меньше либо равен (below or equals) чем op2
```ja oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был больше (above) чем op2
```jae oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 был больше либо равен (above or equals) чем op2
```je oplabel```
Cовершит прыжок на метку oplabel если в предыдущей операции сравнения op1 равен (equals) op2

#### Прыжки зависящие от флагов
```jc oplabel```
Cовершит прыжок на метку oplabel если CF = 1
```jo oplabel```
Cовершит прыжок на метку oplabel если OF = 1
```jz oplabel```
Cовершит прыжок на метку oplabel если ZF = 1
Aналогично
```jnc oplabel```
Cовершит прыжок на метку oplabel если CF = 0
```jno oplabel```
Cовершит прыжок на метку oplabel если OF = 0
```jnz oplabel```
Cовершит прыжок на метку oplabel если ZF = 0
